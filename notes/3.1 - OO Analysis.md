# OO Analysis

## Aggregation Relationship

Common collection relationship is 1 .. *

![alt text](../imgs/3/relationshipex.png)

- Signifies Peer Relationship - neither one is more significant
- Leads to gaps of understanding

Qualified Association

- Reduces multiplicity using "keys"
- Ensures that "same student deosnt appear twice in course"
- Shorthand for ensuring uniqueness within collection based upon marked attribute (id in this case)

Utility

![alt text](../imgs/3/utility.png)

- Captures key-based semantics
- Common in <Name, Value> loopups or databses

### Aggregation

![alt text](../imgs/3/aggregation.png)

- Denotes hierarchal relationship
- Implied "1" over the white-diamond
- "Is there an operation that i would like to preform over all elements in the collection?"

### Composition

![alt text](../imgs/3/polygonex.png)

- When an object cannot exist without a container object
- Consider `Polygon/PolygoneLine` example
- No purpose in having `PolygonLine` object without enclosing `Polygon`
  - Optional (though useful) for `PolygonLine` to reference its "parent"

## How to Analyze

- Identify responsibilities of a class
  - Store information? Define attributes
  - Provide functionality? DEfine methods
  - Does it do too much? Consider splitting into multiple classes
  - S
- Sanity check each method
  - Does the class have *enough information* to meet its functional obligation?
  - If not, then you are missing attribute sand relationships

### Defining methods for classes

![alt text](../imgs/3/game.png)

- Constructors
  - How to construct the objects
  - Pay attention to class relationships
- Ex: How are players added to and removed from `Game` objects?
  - ![alt text](../imgs/3/gamesex.png)

### Methods Describe Behaviors

- Common Idioms
  - Collections / Sets / Bags that support dynamic **add** and **remove**
- Set/Get methods
  - Do not include these ever on the OOAD
  - They will be assumed, and just clutter up space otherwise
- Methods provide functionality
  - Look to use cases for inspiration
- Constructors identify information known when construction object initially
  - Not every attribute in the class belongs as a parameter to the constructor

### Methods realize purpose of class

- Each class has certain responsibilities
- Data/structural responsibilities
  - a `Model` stores the `Puzzle` which stores `Pieces` which have information
  - Navigation lets you locate the information you want
- At this early stage you can still identify capabilities that must exist. Consider `Puzzle`:
  - Need to know if a specific coordinate in puzzle is covered or not
    - `isCovered(coord: Coordinate): boolean`
  - Since it knows the selected piece, it can return a collection of potential moves (up, down, left or right)
    - `availableModes(): MoveType[*]`

## Subsystem structure

![alt text](../imgs/3/subsystemarc.png)

- Boundary objects (grey square)
  - Forms identified during Use Case Analysis
- Controller objects (yellow rectangle)
  - Manage use cases
  - Initiated by actions on the boundary objects
- Entity objects (green circle)
  - Track persistent information
  - NOT persistent objects
- Important subsystems will occasionally be manager objects
  - These define an interface for the system to use

### Design Goals

- Qualities that will be present
  - "Entity objects are not responsible fo their own persistent storage"
- Then must explain HOW info must persist
  - "Controllers responsible for requesting persistent changes"
- Note to shift away from WHAT to HOW
